#################################################################################
#                                                                               #
#        DOCUMENTAÇÃO DA ARQUITETURA DE BACKEND (REVISADA - v1.2)               #
#                                                                               #
#        Sistema: Gestão de Projetos e Melhorias                                #
#        Foco: Alinhado com BD v1.2 e UI Admin-only                             #
#        Data da Documentação: 07 de Maio de 2025                               #
#                                                                               #
#################################################################################

SUMÁRIO:
1.  Visão Geral da Arquitetura
2.  Camada de API (Interface de Programação de Aplicações)
3.  Camada de Aplicação (Serviços de Aplicação)
4.  Camada de Domínio (Lógica de Negócios e Entidades)
5.  Camada de Infraestrutura (Acesso a Dados e Integrações Externas)
6.  Fluxo de Dados para Operações (Exemplos Conceituais Revisados)

---

1.  VISÃO GERAL DA ARQUITETURA
    ---------------------------

O backend será desenvolvido seguindo uma arquitetura em camadas para promover a separação de responsabilidades, manutenibilidade, testabilidade e escalabilidade. As interações com o sistema cliente (frontend) ocorrerão através de uma API RESTful, cujos endpoints serão prefixados com `/backend/v1/`. A linguagem de programação alvo para desenvolvimento posterior será Python, e o design da API deverá seguir as melhores práticas REST.

O "sistema cliente" (frontend) será uma interface administrativa acessada e utilizada **exclusivamente pelo perfil de Administrador** (definido na tabela `usuario`). Todas as funcionalidades do backend e da API serão desenhadas para suportar as tarefas do Administrador, que incluem:
    * Gerenciamento de dados mestre (seções, equipes, recursos, projetos, status, etc.).
    * Planejamento detalhado de horas alocadas por recurso/projeto/mês (conforme `horas_planejadas_alocacao`).
    * Sincronização automática de apontamentos de horas efetivamente trabalhadas a partir do Jira.
    * Criação e gerenciamento (limitado) de apontamentos manuais de horas para casos de exceção.
    * Fornecimento de dados através de consultas flexíveis na API para relatórios resumidos na tela do Admin.
    * Servir como fonte de dados consolidada para ferramentas externas de Business Intelligence (como Power BI) ou para relatórios preparados pelo Administrador para "gestores acima".

O sistema não proverá interface ou acesso direto para usuários com perfil 'recurso' ou 'gestor' (se estes existirem na tabela `usuario` para outros fins).

A arquitetura será composta pelas seguintes camadas principais:
    1.1. Camada de API
    1.2. Camada de Aplicação
    1.3. Camada de Domínio
    1.4. Camada de Infraestrutura

---

2.  CAMADA DE API (INTERFACE DE PROGRAMAÇÃO DE APLICAÇÕES)
    -------------------------------------------------------

* **Propósito Principal:**
    Porta de entrada para todas as requisições do frontend administrativo, gerenciando a comunicação HTTP e roteamento para a Camada de Aplicação.

* **Responsabilidades Chave:**
    * **Exposição de Endpoints:** Definir endpoints RESTful (com prefixo `/backend/v1/`) para todas as funcionalidades do Administrador.
        * **CRUD Completo para Admin:** `secao`, `equipe`, `recurso`, `status_projeto`, `projeto`, `alocacao_recurso_projeto`, `horas_disponiveis_rh`, `horas_planejadas_alocacao`, `usuario` (para gerenciar usuários do sistema), `configuracao`.
        * **Endpoints para `apontamento` (Regras Específicas):**
            * `POST /apontamentos/`: Criação de apontamentos **manuais** pelo Admin.
            * `GET /apontamentos/`: Listagem com **filtros avançados** (por `recurso_id`, `projeto_id`, `data_apontamento` [range], `fonte_apontamento`, `jira_issue_key`, e potencialmente filtros derivados como `equipe_id` ou `secao_id` do recurso) e suporte a **agregações** (ex: soma de `horas_apontadas`).
            * `GET /apontamentos/{id}/`: Detalhe de um apontamento.
            * `PUT /apontamentos/{id}/`: Permitido **APENAS** se o apontamento existente tiver `fonte_apontamento = 'MANUAL'`. Retornar erro 403 (Forbidden) ou 400 (Bad Request) se tentar editar um 'JIRA'.
            * `DELETE /apontamentos/{id}/`: Permitido **APENAS** se o apontamento existente tiver `fonte_apontamento = 'MANUAL'`. Retornar erro se tentar deletar um 'JIRA'.
        * **Endpoints para Logs e Sincronização:**
            * `GET /logs-atividade/`: Para o Admin consultar logs (com filtros).
            * `GET /sincronizacoes-jira/`: Para o Admin ver histórico de sincronizações.
            * (Opcional) `POST /sincronizacoes-jira/`: Para o Admin disparar uma sincronização manual.
        * **Endpoint de Webhook Jira:** `POST /jira/webhooks/worklog` (sem prefixo `/backend/v1/` usual, ou configurável) para receber eventos do Jira.
    * **Recepção e Roteamento:** Mantido.
    * **Validação de Entrada (Sintática):** Mantido (uso de DTOs/Schemas).
    * **Deserialização e Serialização:** Mantido.
    * **Autenticação e Autorização:**
        * Autenticação via token (JWT, OAuth2) para garantir que é um Admin logado.
        * Autorização baseada no papel 'admin' e verificações adicionais nos endpoints de `apontamento` (PUT/DELETE) para aplicar as regras de negócio.
    * **Formatação de Respostas e Tratamento de Erros:** Mantido.

* **Boas Práticas:** Mantidas.

---

3.  CAMADA DE APLICAÇÃO (SERVIÇOS DE APLICAÇÃO)
    --------------------------------------------

* **Propósito Principal:** Orquestrar os casos de uso do Administrador e os processos do sistema (sincronização Jira).
* **Responsabilidades Chave:**
    * **Orquestração de Casos de Uso:** Implementar a lógica para cada funcionalidade acessível ao Admin.
        * Serviços para CRUD completo das entidades base (`SecaoService`, `EquipeService`, `RecursoService`, `StatusProjetoService`, `ProjetoService`, `AlocacaoService`, `HorasDisponiveisRHService`, `UsuarioService`, `ConfiguracaoService`).
        * **`PlanejamentoHorasService`:** Lógica de negócio para CRUD de `horas_planejadas_alocacao`. Inclui validações (ex: não exceder capacidade do recurso no mês, se essa regra for aplicada).
        * **`ApontamentoHoraService`:**
            * **Criação Manual:** Recebe dados do Admin via API, valida, define `fonte_apontamento`='MANUAL', associa o `id_usuario_admin_criador` (do usuário Admin logado), chama o repositório para salvar.
            * **Edição/Deleção Manual:** Recebe requisição da API, busca o apontamento, **verifica se `fonte_apontamento` é 'MANUAL'**. Se for, permite a operação chamando o repositório; senão, retorna erro/exceção.
            * **Consulta:** Recebe parâmetros de filtro avançados da API, orquestra chamadas ao `ApontamentoHoraRepository` (e possivelmente outros repositórios para filtros por equipe/seção) para obter os dados detalhados e as agregações solicitadas.
        * **`JiraWebhookService` (ou dentro do `ApontamentoHoraService`):**
            * Processa os payloads dos webhooks do Jira.
            * Mapeia `accountId` Jira para `recurso_id`.
            * Mapeia `projectKey` / `issueId` Jira para `projeto_id`.
            * Transforma dados do worklog.
            * Chama o `ApontamentoHoraRepository` para **inserir/atualizar/deletar** o registro correspondente ao `jira_worklog_id`, sempre tratando o dado vindo do Jira como a versão mais recente para aquele worklog específico (sem bloqueios por edições prévias do Admin). Define `fonte_apontamento`='JIRA'.
        * **`LogService` / `SincronizacaoJiraService`:** Serviços para gerenciar logs e histórico de sincronizações.
    * **Gerenciamento de Transações:** Mantido.
    * **Validação de Regras de Negócio:** Mantido.
    * **Mapeamento de Dados:** Mantido.
    * **Segurança:** Mantido (foco no Admin).
    * **Tratamento de Falhas na Integração Jira:** Logar erros, talvez armazenar status na `sincronizacao_jira`.

---

4.  CAMADA DE DOMÍNIO (LÓGICA DE NEGÓCIOS E ENTIDADES)
    ---------------------------------------------------

* **Propósito Principal:** Mantido.
* **Responsabilidades Chave:**
    * **Representações de Entidades:** Definir as classes/objetos que representam `secao`, `equipe`, `recurso`, `status_projeto`, `projeto`, `alocacao_recurso_projeto`, `horas_disponiveis_rh`, `horas_planejadas_alocacao`, `apontamento`, `usuario`, `configuracao`, `log_atividade`, `sincronizacao_jira`, `dim_tempo`.
    * **Entidade `apontamento`:** Reforçar que a entidade que representa um apontamento com `fonte_apontamento`='JIRA' não possui métodos de negócio que permitam sua alteração direta por um usuário do sistema. Métodos de alteração só se aplicariam a instâncias 'MANUAL'.
    * **Regras de Negócio:**
        * Validações intrínsecas de cada entidade (ex: `horas_apontadas` > 0).
        * Regras relacionais (ex: validação de `horas_planejadas` vs `horas_disponiveis_mes`).
    * **Interfaces de Repositório:** Definir contratos para todos os repositórios, incluindo os novos (`UsuarioRepository`, `ConfiguracaoRepository`, `LogAtividadeRepository`, `SincronizacaoJiraRepository`, `PlanejamentoHorasRepository`).

---

5.  CAMADA DE INFRAESTRUTURA (ACESSO A DADOS E INTEGRAÇÕES EXTERNAS)
    -----------------------------------------------------------------

* **Propósito Principal:** Mantido.
* **Responsabilidades Chave:**
    * **Acesso a Dados (Repositórios):**
        * **Implementações:** Implementar todas as interfaces de repositório definidas no Domínio.
        * **Novos Repositórios:** `UsuarioRepository`, `ConfiguracaoRepository`, `LogAtividadeRepository`, `SincronizacaoJiraRepository`, `PlanejamentoHorasRepository`.
        * **`ApontamentoHoraRepository` (Revisão Funcional):**
            * `create_manual()`: Salva apontamento com `fonte_apontamento`='MANUAL' e `id_usuario_admin_criador`.
            * `update_manual()`, `delete_manual()`: Executam a ação apenas se o registro alvo tiver `fonte_apontamento`='MANUAL'.
            * `sync_jira_apontamento()` (ou métodos `create_or_update_from_jira`, `delete_from_jira`): Recebem dados processados do Jira e fazem o `INSERT`, `UPDATE` ou `DELETE` no banco com base no `jira_worklog_id`, **sem checar** se o Admin modificou antes.
            * `find_with_filters_and_aggregate()`: Método(s) para suportar as consultas complexas da API, possivelmente usando VIEWS do banco de dados para performance.
        * **Outros Repositórios:** Implementar métodos de busca com filtros conforme necessário para as consultas do Admin.
    * **Integração com Jira (`JiraClient`):** Mantido como o cliente HTTP para a API do Jira.
    * **Outros Serviços Externos:** Mantido (se houver).
    * **Mecanismos de Resiliência:** Mantido.
    * **Gerenciamento de Conexão com BD:** Mantido.
    * **Persistência de Logs:** O `LogAtividadeRepository` salva registros na `log_atividade`.

---

6.  FLUXO DE DADOS PARA OPERAÇÕES (EXEMPLOS CONCEITUAIS REVISADOS)
    -----------------------------------------------------------

* **Exemplo: Criação de Apontamento Manual (pelo Admin):**
    1. API recebe POST do Admin.
    2. Aplicação (`ApontamentoHoraService`) valida, define fonte='MANUAL', pega `id_usuario` do Admin logado, chama repo.
    3. Infra (`ApontamentoHoraRepository`) insere na `apontamento`, incluindo `id_usuario_admin_criador`.

* **Exemplo: Edição de Apontamento (pelo Admin):**
    1. API recebe PUT do Admin para `/apontamentos/{id}`.
    2. Aplicação (`ApontamentoHoraService`) busca o apontamento pelo ID.
    3. Aplicação **verifica se `fonte_apontamento` == 'MANUAL'**.
    4. Se SIM: valida os novos dados, chama `repo.update_manual()`.
    5. Se NÃO: Retorna erro (403 Forbidden / 400 Bad Request).
    6. Infra (`ApontamentoHoraRepository`) atualiza apenas se chamado pelo fluxo correto.

* **Exemplo: Sincronização de Worklog ATUALIZADO do Jira:**
    1. API recebe webhook `worklog_updated` do Jira.
    2. Aplicação (`JiraWebhookService` / `ApontamentoHoraService`) processa, mapeia dados, identifica o `jira_worklog_id`.
    3. Aplicação chama `repo.sync_jira_apontamento()` (ou método similar de update).
    4. Infra (`ApontamentoHoraRepository`) executa um `UPDATE` na tabela `apontamento` WHERE `jira_worklog_id` = [ID recebido], sobrescrevendo quaisquer dados anteriores para aquele registro.

* **NOVO EXEMPLO: Admin Planeja Horas Mensais:**
    1. API recebe `POST /planejamento-horas/` do Admin com dados (`alocacao_id`, `ano`, `mes`, `horas_planejadas`).
    2. Aplicação (`PlanejamentoHorasService`) valida (alocação existe? horas vs capacidade do recurso?).
    3. Aplicação chama `repo.create_or_update_planejamento()`.
    4. Infra (`PlanejamentoHorasRepository`) salva/atualiza na `horas_planejadas_alocacao`.

---

Esta versão revisada da documentação do backend deve estar agora alinhada com o BD v1.2 e as regras operacionais focadas no Administrador como único usuário interativo do sistema.

